/*** SmartFoxServer 2X Examples: Simple MMO World* * (c) 2009 - 2013 gotoAndPlay()*/package classes{	import com.smartfoxserver.v2.SmartFox;	import com.smartfoxserver.v2.core.SFSEvent;	import com.smartfoxserver.v2.entities.*;	import com.smartfoxserver.v2.entities.data.*;	import com.smartfoxserver.v2.entities.variables.*;	import com.smartfoxserver.v2.requests.*;	import com.smartfoxserver.v2.requests.mmo.*;	import com.smartfoxserver.v2.util.ClientDisconnectionReason;		import flash.display.*;	import flash.events.*;	import flash.utils.*;		import com.greensock.TweenNano;	import com.greensock.easing.*;	import fl.events.ComponentEvent;	public class SimpleMMOWorld extends MovieClip	{		private const VIEW_CONNECT:String = "connect";		private const VIEW_JOIN:String = "join";		private const VIEW_MAP:String = "map";				private const MMO_ROOM_NAME:String = "The Map";				private const USERVAR_X:String = "x";		private const USERVAR_Y:String = "y";		private const USERVAR_DIR:String = "dir";				private const AVATAR_DIRECTIONS:Array = ["E", "SE", "S", "SW", "W", "NW", "N", "NE"];		private const AVATAR_SPEED:int = 100; // Expressed in pixels/sec				private const VIEWPORT_PADDING:int = 50;		private const VIEWPORT_PADDING_ADJUST:int = 16;						private var sfs:SmartFox;		private var currentView:String = "";		private var errorMsg:String = "";		private var accessX:int = -1;		private var accessY:int = -1;		private var mapObjects:Array;				public function SimpleMMOWorld()		{			// Create an instance of the SmartFox class		 	sfs = new SmartFox();					// Add SFS2X event listeners			sfs.addEventListener(SFSEvent.CONNECTION, onConnection);			sfs.addEventListener(SFSEvent.CONNECTION_LOST, onConnectionLost);			sfs.addEventListener(SFSEvent.LOGIN, onLogin);			sfs.addEventListener(SFSEvent.LOGIN_ERROR, onLoginError);			sfs.addEventListener(SFSEvent.CONNECTION_LOST, onConnectionLost);			sfs.addEventListener(SFSEvent.ROOM_JOIN, onRoomJoin);			sfs.addEventListener(SFSEvent.ROOM_JOIN_ERROR, onRoomJoinError);			sfs.addEventListener(SFSEvent.USER_EXIT_ROOM, onUserExitRoom);			sfs.addEventListener(SFSEvent.PROXIMITY_LIST_UPDATE, onProximityListUpdate);			sfs.addEventListener(SFSEvent.USER_VARIABLES_UPDATE, onUserVarsUpdate);			sfs.addEventListener(SFSEvent.PUBLIC_MESSAGE, onPublicMessage);		}				/**		 * Called by the 'connect' frame.		 * Takes care of adding the listener to the login button.		 */		public function initConnectView():void		{			stop();			currentView = this.currentLabel;						// Enable interface (in case we returned to the connect view due to a previous disconnection)			panel_login.bt_login.enabled = true;			panel_login.ti_username.enabled = true;			panel_login.tf_error.text = errorMsg;						// Add login button click listener			if (!panel_login.bt_login.hasEventListener(MouseEvent.CLICK))				panel_login.bt_login.addEventListener(MouseEvent.CLICK, onLoginBtClick, false, 0, true);		}				/**		 * Called by the 'join' frame.		 * The example is sent to this frame as soon as the LOGIN event is received,		 * or if the user is kicked out of a Room due to exceeding the 'userMaxLimboSeconds' settings of the MMORoom.		 */		public function initJoinView():void		{			stop();			currentView = this.currentLabel;						// Enable interface			panel_join.bt_join.enabled = true;			panel_join.ns_px.enabled = true;			panel_join.ns_py.enabled = true;						// Set numeric steppers max & min values based on map limits defined in the MMORoom settings			var room:MMORoom = sfs.roomManager.getRoomByName(MMO_ROOM_NAME) as MMORoom;			panel_join.ns_px.maximum = room.higherMapLimit.px;			panel_join.ns_py.maximum = room.higherMapLimit.py;			panel_join.ns_px.minimum = -1;			panel_join.ns_py.minimum = -1;						// Set x and y numeric steppers value; -1 is used for random coordinates			panel_join.ns_px.value = -1;			panel_join.ns_py.value = -1;						// Add join button click listener			if (!panel_join.bt_join.hasEventListener(MouseEvent.CLICK))				panel_join.bt_join.addEventListener(MouseEvent.CLICK, onJoinBtClick, false, 0, true);		}				/**		 * Called by the 'map' frame.		 * The example is sent to this frame as soon as the ROOM_JOIN event is received.		 */		public function initMapView():void		{			stop();			currentView = this.currentLabel;						// Nothing special to do here, because in this example we just have one map			// and all assets are self-contained in the swf, so no loading of external files is required			// Otherwise assets loading should probably occurr here and the next statements moved at the end of it			// Also, avatar panel is useful in this example to set the entry coordinates for testing purposes,			// but usually this is skipped and predefined entry points exist						// Add public message send button click listener			if (!panel_controls.bt_sendChatMsg.hasEventListener(MouseEvent.CLICK))				panel_controls.bt_sendChatMsg.addEventListener(MouseEvent.CLICK, onSendBtClick, false, 0, true);						if (!panel_controls.ti_chatMsgInput.hasEventListener(ComponentEvent.ENTER))				panel_controls.ti_chatMsgInput.addEventListener(ComponentEvent.ENTER, onSendBtClick, false, 0, true);						// Add curtain fader change listener			if (!panel_controls.sl_fader.hasEventListener(Event.CHANGE))				panel_controls.sl_fader.addEventListener(Event.CHANGE, onFaderSlChange, false, 0, true);							// Add map click listener			if (!mapArea.hasEventListener(MouseEvent.MOUSE_DOWN))				mapArea.addEventListener(MouseEvent.MOUSE_DOWN, onMapAreaClick, false, 0, true);						// Create an array that will contain all map objects, including avatars, used for sprites sorting purposes			// The trees already existing on the map are added to this array now (while making them transparent to clicks)			mapObjects = new Array();						for (var i:int = 0; i < mapArea.avContainer.numChildren; i++)			{				var obj:Sprite = mapArea.avContainer.getChildAt(i);				obj.mouseChildren = false;				obj.mouseEnabled = false;				mapObjects.push(obj);			}						// Set the random position of the current user on the map (if coordinates are not selected by the user)			if (accessX < 0)				accessX = Math.round(Math.random() * mapArea.width);			if (accessY < 0)				accessY = Math.round(Math.random() * mapArea.height);						// Avoid making the avatar appear in the middle of the river (non-walkable area) by excluding the map's bottom left corner			if (accessY > 430)				accessX = Math.max(accessX, 830);						// Set starting direction to a default value			var dir:String = AVATAR_DIRECTIONS[2];						// Create current user's avatar			createAvatar(sfs.mySelf, accessX, accessY, dir);						// The position is saved in the User Variables, so that changing it later will trigger the avatar animation			setAvatarVariables(accessX, accessY, dir);						// Declare current user's position in the MMORoom, to get the proximity list of users			updateServerPosition();		}				//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::		// User interface handlers		//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::				/**		 * Makes the SmartFox client attempt to connect to the server by loading the external configuration.		 * If successful, the login is attempted immediately after.		 */		private function onLoginBtClick(evt:Event):void		{			// Disable interface			panel_login.bt_login.enabled = false;			panel_login.ti_username.enabled = false;			panel_login.tf_error.text = errorMsg = "";						// Attempt connection			sfs.loadConfig();		}				/**		 * Makes the user join the only MMORoom available in this example.		 */		private function onJoinBtClick(evt:Event):void		{			// Disable interface			panel_join.bt_join.enabled = false;			panel_join.ns_px.enabled = false;			panel_join.ns_py.enabled = false;						// Save selected map entry position for later usage			accessX = panel_join.ns_px.value;			accessY = panel_join.ns_py.value;						// Attempt Room join			sfs.send( new JoinRoomRequest(MMO_ROOM_NAME) );		}				/**		 * Sends a public message to be displayed avatar's chat bubble of the current user.		 */		private function onSendBtClick(evt:Event):void		{			if (panel_controls.ti_chatMsgInput.text != "")			{				// Send public chat message				sfs.send( new PublicMessageRequest(panel_controls.ti_chatMsgInput.text) );								// Reset text input				panel_controls.ti_chatMsgInput.text = "";			}		}				/**		 * Changes the opacity of the grayed area.		 */		private function onFaderSlChange(evt:Event):void		{			drawCurtain();		}				/**		 * Handles user clicks on the map area.		 * Destination coordinates are saved as SmartFoxServer User Variables.		 * Also, the direction faced by the avatar is calculated and saved as User Variable.		 * 		 * NOTE: the avatar of the current user starts moving once the USER_VARIABLES_UPDATE event		 * is received, just like on the other clients. This can cause a delay in case of network lag.		 */		private function onMapAreaClick(evt:MouseEvent):void		{			// Retrieve destination coordinates			var destX:int = evt.localX;			var destY:int = evt.localY;						// Skip map click if the destination coordinates hit the map's non-walkable area			if (isNonWalkable(destX, destY))				return;						// Get current coordinates			var myAvatar:Avatar = getAvatar(sfs.mySelf.id);			var currX:int = myAvatar.x;			var currY:int = myAvatar.y;						// Evaluate avatar movement direction			var dx:Number = destX - currX;			var dy:Number = destY - currY;						var angle:Number = Math.atan(dy / dx);						var deg:Number = Math.round(angle * 180 / Math.PI);			if(dx < 0)				deg += 180;			else if(dx >= 0 && dy < 0)				deg += 360;						var dirIndex:Number = Math.round(deg / 45);			if (dirIndex >= AVATAR_DIRECTIONS.length)				dirIndex -= AVATAR_DIRECTIONS.length;						var dir:String = AVATAR_DIRECTIONS[dirIndex];						// Save destination coordinates and direction in User Variables			setAvatarVariables(destX, destY, dir);		}				//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::		// SFS2X Event handlers		//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::				/**		 * Sends a login request to the server.		 */		private function onConnection(evt:SFSEvent):void		{			if (evt.params.success)			{				// Login				sfs.send( new LoginRequest(panel_login.ti_username.text) );			}			else			{				// Set message to be displayed in connection view				errorMsg = "Unable to connect to " + sfs.config.host + ":" + sfs.config.port + "\nIs the server running at all?";								// Re-init the view, so the interface controls are enabled again				initConnectView();			}		}				/**		 * Displays the disconnection reason.		 */		private function onConnectionLost(evt:SFSEvent):void		{			var reason:String = evt.params.reason;						if (reason != ClientDisconnectionReason.MANUAL)			{				// Set message to be displayed in connection view				if (reason == ClientDisconnectionReason.IDLE)					errorMsg = "A disconnection occurred due to inactivity";				else if (reason == ClientDisconnectionReason.KICK)					errorMsg = "You have been kicked by the moderator";				else if (reason == ClientDisconnectionReason.BAN)					errorMsg = "You have been banned by the moderator";				else					errorMsg = "A disconnection occurred due to unknown reason; please check the server log";			}			else			{				// Manual disconnection is usually ignored			}						if (currentView != VIEW_CONNECT)				this.gotoAndPlay(VIEW_CONNECT);			else				initConnectView();		}				/**		 * Moves the view to the MMORoom selection (this example features one Room only).		 */		private function onLogin(evt:SFSEvent):void		{			// Show map selection view; initJoinView method will be called			this.gotoAndPlay(VIEW_JOIN);		}				/**		 * Display an error occurred during Room join.		 */		private function onLoginError(evt:SFSEvent):void		{			// Set message to be displayed in connection view			errorMsg = evt.params.errorMessage;						// Re-init the view, so the interface controls are enabled again and the error displayed			initConnectView();		}				/**		 * Moves the view to the map frame.		 */		private function onRoomJoin(evt:SFSEvent):void		{			// Show the map; initMapView method will be called			this.gotoAndStop(VIEW_MAP);		}				/**		 * Display the map access panel in case an error occurred during Room join.		 */		private function onRoomJoinError(evt:SFSEvent):void		{			// An error should be displayed in the interface						// Re-init the view, so the interface controls are enabled again			initJoinView();		}				/**		 * Sends to join view in case current user doesn't set his initial position.		 *		 * An MMORoom removes a user in case his position is not set within the configured time (see userMaxLimboSeconds setting on the Room).		 */		private function onUserExitRoom(evt:SFSEvent):void		{			// Show the join view; initJoinView method will be called			if (evt.params.user == sfs.mySelf)				this.gotoAndStop(VIEW_JOIN);		}				/**		 * Called whenever a proximity list change occurs.		 * This can be caused by the current user's avatar movement or other users entering/leaving		 * the current user Area o Interest (AoI).		 * 		 * The addedUsers list contains the users that entered the current user's AoI since the last update.		 * Each user has a conventional property declaring its entry position.		 */		private function onProximityListUpdate(evt:SFSEvent):void		{			// Loop the removedUsers list in the event params to remove the avatars no more visible			var removed:Array = evt.params.removedUsers;			for each (var ru:User in removed)			{				var ra:Avatar = getAvatar(ru.id);								if (ra != null)					removeAvatar(ra);			}						// Loop the addedUsers list in the event params to display the avatars now visible			var added:Array = evt.params.addedUsers;			for each (var au:User in added)			{				// Get user entry point				var vec:Vec3D = au.aoiEntryPoint as Vec3D;								// Get avatar direction from User Variables				var dir:String = au.getVariable(USERVAR_DIR).getStringValue();								// Create avatar				createAvatar(au, vec.px, vec.py, dir);								// Make the avatar move towards the coordinates set in the User Variables if they are different from the entry point				if (au.containsVariable(USERVAR_X) && au.containsVariable(USERVAR_Y))				{					var px:int = au.getVariable(USERVAR_X).getIntValue();					var py:int = au.getVariable(USERVAR_Y).getIntValue();										if (px != vec.px || py != vec.py)						moveAvatar(au);				}			}						// Arrange map objects sorting			arrangeMapObjects();		}				/**		 * Makes an avatar move as soon as its position (saved in User Variables) changes.		 */		private function onUserVarsUpdate(evt:SFSEvent):void		{			var changedVars:Array = evt.params.changedVars as Array;			var user:User = evt.params.user as User;						// Check if the user changed his position			if (changedVars.indexOf(USERVAR_X) != -1 || changedVars.indexOf(USERVAR_Y) != -1)			{				// Check if avatar exists				if (getAvatar(user.id) != null)				{					// Move the user avatar					moveAvatar(user);				}			}		}				/**		 * Shows the chat message in a bubble on the avatar of the sender.		 */		private function onPublicMessage(evt:SFSEvent):void		{			var sender:User = evt.params.sender;			var msg:String = evt.params.message;						var avatar:Avatar = getAvatar(sender.id);						// Check if avatar exists			if (avatar != null)			{				// Show the chat message				avatar.showChatMessage(msg);			}		}		//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::		// Private methods		//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::				/**		 * Returns a reference to an avatar from the user id of its owner.		 */		private function getAvatar(userId:int):Avatar		{			return mapArea.avContainer.getChildByName(String(userId));		}				/**		 * Creates the avatar of a user.		 */		private function createAvatar(user:User, x:int, y:int, dir:String):void		{			// Instantiate avatar			var avatar:Avatar = new Avatar(user.id, user.name);						// Set avatar position and initialize "next" coordinates too (see moveAvatar method)			avatar.x = avatar.nextX = x;			avatar.y = avatar.nextY = y;						// Set initial avatar graphics			avatar.setGraphics("stand", dir);						// NOTE			// As this example is used for testing purposes too, we reconfigure the AoI frame (dashed red) based on the MMORoom settings			// and the viewport frame (solid black) as a smaller portion of the AoI. Of course in a real case scenario the vieport is fixed			// and the AoI must be configured accordingly, so that it is bigger of the actual viewport.			// This approach (AoI > vieport) is very important because it allows to have a padding area where avatars appear and disappear			// outside of the visible portion of the map while the current user moves around. Having an AoI <= viewport would cause the avatars			// to pop in and out of the view.						avatar.myAOIFrame.visible = user.isItMe;			avatar.myViewportFrame.visible = user.isItMe;						if (user.isItMe)			{				var room:MMORoom = sfs.lastJoinedRoom as MMORoom;				avatar.myAOIFrame.width = room.defaultAOI.px * 2;				avatar.myAOIFrame.height = room.defaultAOI.py * 2;								avatar.myViewportFrame.width = avatar.myAOIFrame.width - (VIEWPORT_PADDING * 2);				avatar.myViewportFrame.height = avatar.myAOIFrame.height - (VIEWPORT_PADDING * 2);								// As in this example a 2.5D view is used (isometric), we need the bottom padding between the AoI and the viewport				// to be bigger, to avoid seeing an avatar disappear suddenly as soon as his feet fall outside the AoI.				avatar.myViewportFrame.height -= VIEWPORT_PADDING_ADJUST;				avatar.myViewportFrame.y -= VIEWPORT_PADDING_ADJUST / 2;			}						// Add avatar to avatars container			mapArea.avContainer.addChild(avatar);						// Add avatar to array used for sorting			mapObjects.push(avatar);						// Draw curtain masking area outside of vieport			if (user.isItMe)				drawCurtain();		}				/**		 * Destroys an avatar.		 */		private function removeAvatar(avatar:Avatar):void		{			// Remove tween			TweenNano.killTweensOf(avatar, false);						// Remove avatar from stage			mapArea.avContainer.removeChild(avatar);						// Destroy avatar			avatar.destroy();						// Remove avatar from array used for sorting purposes			var index:int = mapObjects.indexOf(avatar);			mapObjects.splice(index, 1);		}				/**		 * Saves the avatar position and direction in the User Variables.		 */		private function setAvatarVariables(px:int, py:int, dir:String):void		{			var userVars:Array = [];			userVars.push(new SFSUserVariable(USERVAR_X, px));			userVars.push(new SFSUserVariable(USERVAR_Y, py));						if (dir != null)				userVars.push(new SFSUserVariable(USERVAR_DIR, dir));						sfs.send(new SetUserVariablesRequest(userVars));		}				/**		 * Rearranges the avatars and trees depths in their container (z-sorting).		 *		 * NOTE: as this would be out of the scope of this example, we didn't put too much effort		 * in the sorting method used to rearrange the avatar depths. In fact this method is not		 * particularly efficient, because at each animation step all avatars and trees are rearranged.		 */		private function arrangeMapObjects():void		{			// Sort avatars based on their y coordinate			mapObjects.sortOn("y", Array.NUMERIC);						var i:int = mapObjects.length;						while (i--)			{				if (mapArea.avContainer.getChildIndex(mapObjects[i]) != i)					mapArea.avContainer.setChildIndex(mapObjects[i], i);			}		}				/**		 * Creates the tween to animate the avatar from the current postion to the		 * destination coordinates saved in the User Variables.		 *		 * During the movement we have to update the current user's position in the MMORoom		 * so that his proximity list is updated accordingly.		 */		private function moveAvatar(user:User):void		{			var avatar:Avatar = getAvatar(user.id);						// Stop previous animation if any			TweenNano.killTweensOf(avatar);						// Retrieve User Variables			var px:int = user.getVariable(USERVAR_X).getIntValue();			var py:int = user.getVariable(USERVAR_Y).getIntValue();			var dir:String = user.getVariable(USERVAR_DIR).getStringValue();						// Make avatar play walking animation			avatar.setGraphics("walk", dir);						// Calculate animation duration			// (we want the avatar to move at a constant speed)			var dx:Number = px - avatar.x;			var dy:Number = py - avatar.y;			var dist:Number = Math.round(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)));						var duration:Number = dist / AVATAR_SPEED;						// Move the avatar to the new position			// (check the tween class documentation here: http://www.greensock.com/as/docs/tween/)			// We use the "next" custom properties so we can validate the coordinates during the movement before actually setting it			// In this way we can make the avatar stop if it crosses a non-walkable area						var twParams:Object = {};			twParams.nextX = px;			twParams.nextY = py;			twParams.ease = Linear.easeNone;			twParams.onUpdate = onAvatarTweenUpdate;			twParams.onUpdateParams = [avatar];			twParams.onComplete = onAvatarTweenComplete;			twParams.onCompleteParams = [avatar,dir];						TweenNano.to(avatar, duration, twParams);		}				/**		 * Updates the current user's position in the MMORoom each time his avatar crosses half the padding		 * between the AoI and the actual viewport. This makes the avatars entering/leaving the AoI of the user		 * appear/disappear before they become visible/invisible.		 *		 * For the current user's avatar, if it steps on a non-walkable area, the movement is stopped.		 * 		 * This method also updates the z-sorting of all avatars at each animation step and redraws the curtain.		 */		private function onAvatarTweenUpdate(avatar:Avatar):void		{			if (avatar.name == String(sfs.mySelf.id))			{				// Check if the next position of the current user's avatar is on a non-walkable area and in case stop it				if (isNonWalkable(avatar.nextX, avatar.nextY))				{					// Stop current animation					TweenNano.killTweensOf(avatar);										// Set position to the current coordinates, so all clients will make the avatar reach the same position					// The previous direction is used					setAvatarVariables(avatar.x, avatar.y, null);				}				else				{					// Update avatar position to the "next" coordinates set by the tween					avatar.x = avatar.nextX;					avatar.y = avatar.nextY;										// Save the user posion in the MMORoom					var lastUpdateX:Number = avatar.lastUpdateX;					var lastUpdateY:Number = avatar.lastUpdateY;										var diffX:Number = Math.abs(avatar.x - lastUpdateX);					var diffY:Number = Math.abs(avatar.y - lastUpdateY);										if (diffX >= VIEWPORT_PADDING / 2 || diffY >= VIEWPORT_PADDING / 2)						updateServerPosition();				}			}			else			{				// Always update coordinates for avatar of other users				avatar.x = avatar.nextX;				avatar.y = avatar.nextY;			}						// Arrange nap objects sorting			arrangeMapObjects();						// Update viewport curtain			drawCurtain();		}				/**		 * Makes a walking avatar show the standing animation on movement completion.		 * Also updates the current user's position in the MMORoom.		 */		private function onAvatarTweenComplete(avatar:Avatar, dir:String):void		{			avatar.setGraphics("stand", dir);						if (avatar.name == String(sfs.mySelf.id))				updateServerPosition();		}				/**		 * Checks if the passed coordinates hit the non-walkable area of the map.		 */		private function isNonWalkable(px:Number, py:Number)		{			var hit:Boolean = mapArea.noWalkArea.hitTestPoint(px, py, true);						return hit;		}				/**		 * Updates the current user's position in the MMORoom, so that all users affected		 * by the avatar movement receive a PROXIMITY_LIST_UPDATE event.		 */		private function updateServerPosition():void		{			var myAvatar:Avatar = getAvatar(sfs.mySelf.id);						// Save the coordinates corresponding to the saved position, to be checked during the next tween update			myAvatar.lastUpdateX = Math.round(myAvatar.x);			myAvatar.lastUpdateY = Math.round(myAvatar.y);						var pos:Vec3D = new Vec3D(myAvatar.lastUpdateX, myAvatar.lastUpdateY, 0);			sfs.send( new SetUserPositionRequest(pos) );		}				/**		 * Hides the map outside the viewport.		 */		private function drawCurtain():void		{			var g:Graphics = mapArea.curtain.graphics;						g.clear();						if (panel_controls.sl_fader.value > 0)			{				g.beginFill(0x666666, panel_controls.sl_fader.value);				g.drawRect(0, 0, (sfs.lastJoinedRoom as MMORoom).higherMapLimit.px, (sfs.lastJoinedRoom as MMORoom).higherMapLimit.py);								var avatar:Avatar = getAvatar(sfs.mySelf.id);								if (avatar != null)				{					var room:MMORoom = sfs.lastJoinedRoom as MMORoom;					var viewport:MovieClip = avatar.myViewportFrame;					g.drawRect(avatar.x - viewport.width/2, avatar.y - viewport.height/2 + viewport.y, viewport.width + 1, viewport.height);				}								g.endFill();			}		}
		
		public function doMath():void
		{
			ExtensionRequest("math");
		}	}}