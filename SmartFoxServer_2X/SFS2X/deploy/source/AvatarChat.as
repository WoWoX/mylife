/*** SmartFoxServer 2X Examples: AvatarChat* * (c) 2009 - 2011 gotoAndPlay()*/package{	import com.smartfoxserver.v2.SmartFox	import com.smartfoxserver.v2.core.SFSEvent	import com.smartfoxserver.v2.entities.*	import com.smartfoxserver.v2.entities.data.*	import com.smartfoxserver.v2.entities.variables.*	import com.smartfoxserver.v2.requests.*
			import flash.display.*	import flash.events.*	import flash.utils.*		import com.greensock.TweenNano	import com.greensock.easing.*		import flash.utils.clearTimeout;	public class AvatarChat extends MovieClip	{
				private const USERVAR_X:String = "x"		private const USERVAR_Y:String = "y"		private const USERVAR_DIR:String = "dir"				private const AVATAR_DIRECTIONS:Array = ["E", "SE", "S", "SW", "W", "NW", "N", "NE"]		private const AVATAR_SPEED:int = 100 // Expressed in pixels/sec				private var sfs:SmartFox		private var avatars:Array				public function AvatarChat()		{			// Nothing to do		}				/**		 * Method called by the 'connect' frame.		 * It takes care of adding the listeners to SmartFoxServer 2X events.		 */		public function initConnect():void		{			// Stop on current frame			stop()						// Get the instance of the SmartFox class from the SmartFoxBits' Connector		 	sfs = connector.connection					// Add SFS2X event listeners			sfs.addEventListener(SFSEvent.LOGIN, onLogin)			sfs.addEventListener(SFSEvent.CONNECTION_LOST, onConnectionLost)			sfs.addEventListener(SFSEvent.ROOM_JOIN, onRoomJoin)			sfs.addEventListener(SFSEvent.USER_ENTER_ROOM, onUserEnterRoom)			sfs.addEventListener(SFSEvent.USER_EXIT_ROOM, onUserExitRoom)			sfs.addEventListener(SFSEvent.USER_VARIABLES_UPDATE, onUserVarsUpdate)			sfs.addEventListener(SFSEvent.PUBLIC_MESSAGE, onPublicMessage)		}				/**		 * Method called by the 'chat' frame.		 * It takes care of adding the listeners to the user interface		 */		public function initChat():void		{			stop()						// Show current user name			panel_sidebar.lb_myUserName.text = sfs.mySelf.name						// Add listener to Send button			panel_chat.bt_sendChatMsg.addEventListener(MouseEvent.CLICK, onBtSendClick)						// Add click listener to avatars area			panel_chat.avArea.addEventListener(MouseEvent.MOUSE_DOWN, onAvAreaClick)		}				//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::		// User interface handlers		//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::				/**		 * This method sends a public message to be displayed avatar's chat bubble of the current user.		 */		private function onBtSendClick(evt:Event):void		{			if (panel_chat.ti_chatMsgInput.text != "")			{				// Send public chat message				sfs.send( new PublicMessageRequest(panel_chat.ti_chatMsgInput.text) );								// Reset text input				panel_chat.ti_chatMsgInput.text = ""			}		}				/**		 * This method handles user clicks on the avatars area.		 * Destination coordinates are saved as SmartFoxServer User Variables.		 * Also, the direction faced by the avatar is calculated and saved as User Variable.		 * 		 * NOTE: the user avatar of the current user starts moving once the USER_VARIABLES_UPDATE event		 * is received, just like on the other clients. This can cause a delay in case of network lag, so a better		 * approach would be to start the movement immediately (this woul require modifing the onUserVarsUpdate method too).		 */		private function onAvAreaClick(evt:MouseEvent):void		{			if (sfs.isConnected)			{				// Retrieve destination coordinates				var destX:int = evt.localX				var destY:int = evt.localY								// Get current coordinates				var myAvatar:Avatar = getAvatar(sfs.mySelf.id)				var currX:int = myAvatar.x				var currY:int = myAvatar.y								// Evaluate avatar movement direction				var dx:Number = destX - currX				var dy:Number = destY - currY								var angle:Number = Math.atan(dy / dx)								var deg:Number = Math.round(angle * 180 / Math.PI)				if(dx < 0)					deg += 180				else if(dx >= 0 && dy < 0)					deg += 360								var dirIndex:Number = Math.round(deg / 45)				if (dirIndex >= AVATAR_DIRECTIONS.length)					dirIndex -= AVATAR_DIRECTIONS.length								var dir:String = AVATAR_DIRECTIONS[dirIndex]								// Save destination coordinates and direction in User Variables				setAvatarVariables(destX, destY, dir)			}		}				//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::		// SFS2X Event handlers		//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::				/**		 * This event handler shows the main application view on login.		 */		private function onLogin(evt:SFSEvent):void		{			gotoAndStop("chat")		}				/**		 * This event handler disables user interface components on disconnection from server.		 */		private function onConnectionLost(evt:SFSEvent):void		{			// Disable public messages input			if (panel_chat != null)			{				panel_chat.bt_sendChatMsg.enabled = false				panel_chat.ti_chatMsgInput.enabled = false			}		}				/**		 * This event handler creates the avatars of all users in the joined room.		 * In case a previous room was joined, all previous avatars are removed too.		 */		private function onRoomJoin(evt:SFSEvent):void		{			var room:Room = evt.params.room						// Remove avatars of previous room			while (panel_chat.avArea.avContainer.numChildren > 0)				removeAvatar(getAvatar(0))						// Reset array containing all avatars			// It is used for sprites sorting purposes			avatars = new Array()						// Create avatars of users in new room			for each (var u:User in room.userList)				createAvatar(u, false)						// Arrange avatars sorting			arrangeAvatars()						// Create current user's avatar by setting its position user variables to a random value			// This is required the first time only, because we are not clearing user position			// when the room is changed			if (!sfs.mySelf.containsVariable(USERVAR_X) && !sfs.mySelf.containsVariable(USERVAR_Y))			{				var px:int = Math.round(Math.random() * panel_chat.avArea.width)				var py:int = Math.round(Math.random() * panel_chat.avArea.height)				var dir:String = AVATAR_DIRECTIONS[2]								setAvatarVariables(px, py, dir)			}		}				/**		 * This event handler makes an avatar move as soon as its position (saved in User Variables) changes.		 * In case the avatar doesn't exist (for example because the position is set after the room is joined)		 * this method also creates the avatar.		 */		private function onUserVarsUpdate(evt:SFSEvent):void		{			var changedVars:Array = evt.params.changedVars as Array;			var user:User = evt.params.user as User;						// Check if the user changed his position			if (changedVars.indexOf(USERVAR_X) != -1 || changedVars.indexOf(USERVAR_Y) != -1)			{				// Check if avatar exists				if (getAvatar(user.id) != null)				{					// Move the user avatar					moveAvatar(user)				}				else				{					// Create the user avatar					createAvatar(user, true)				}			}		}				/**		 * This event handler creates an avatar as soon as its owner enters the current room.		 */		private function onUserEnterRoom(evt:SFSEvent):void		{			var user:User = evt.params.user						createAvatar(user, true)		}				/**		 * This event handler removes an avatar as soon as its owner leaves the current room.		 * As the current user receives this event too, we have to skip it because we are not		 * removing the avatar of the current user.		 */		private function onUserExitRoom(evt:SFSEvent):void		{			var user:User = evt.params.user						if (!user.isItMe)			{				var avatar:Avatar = getAvatar(user.id)								if (avatar != null)					removeAvatar(avatar)			}		}				/**		 * This event handler shows the chat message in a bubble on the avatar of the sender.		 */		private function onPublicMessage(evt:SFSEvent):void		{			var sender:User = evt.params.sender			var msg:String = evt.params.message						var avatar:Avatar = getAvatar(sender.id)						// Remove previous chat bubble, if any			closeChatBubble(avatar)						// Show new chat bubble			avatar.chatBubble.visible = true			avatar.chatBubble.message.text = msg						// Attach timer to hide the bubble to the avatar itself			avatar.chatTimer = setTimeout(closeChatBubble, 5000, avatar)		}		//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::		// Private methods		//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::				/**		 * This method returns a reference to an avatar from the user id of its owner.		 */		private function getAvatar(userId:int):Avatar		{			return panel_chat.avArea.avContainer.getChildByName(String(userId))		}				/**		 * This method creates the avatar of a user, provided that its position is set in the User Variables.		 */		private function createAvatar(user:User, sort:Boolean):void		{			// Only users with set coordinates have an avatar			if (user.containsVariable(USERVAR_X) && user.containsVariable(USERVAR_Y))			{				// Instantiate avatar				var avatar:Avatar = new Avatar()				avatar.name = String(user.id)				avatar.lb_name.text = user.name				avatar.x = user.getVariable(USERVAR_X).getIntValue()				avatar.y = user.getVariable(USERVAR_Y).getIntValue()				avatar.mouseEnabled = false				avatar.mouseChildren = false								// Setup avatar graphics				avatar.myAvatarSymbol.visible = user.isItMe				avatar.chatBubble.visible = false				setAvatarGraphics(avatar, "stand", user.getVariable(USERVAR_DIR).getStringValue())								// Add avatar to avatars container				panel_chat.avArea.avContainer.addChild(avatar)								// Add avatar to array used for sorting				avatars.push(avatar)								if (sort)					arrangeAvatars()			}		}				/**		 * This method destroys an avatar.		 */		private function removeAvatar(avatar:Avatar):void		{			// Remove tween			TweenNano.killTweensOf(avatar, false)						// Close chat bubble			closeChatBubble(avatar)						// Remove avatar from stage			panel_chat.avArea.avContainer.removeChild(avatar)						// Remove avatar from array used for sorting purposes			var index:int = avatars.indexOf(avatar)			avatars.splice(index, 1)		}				/**		 * This method makes the avatar execute the proper action (stand or walk) in the proper direction.		 */		private function setAvatarGraphics(avatar:Avatar, action:String, dir:String):void		{			avatar.avatarGraphics.gotoAndStop(action + "_" + dir)		}				/**		 * This method saves the avatar position and direction in the User Variables.		 */		private function setAvatarVariables(px:int, py:int, dir:String):void		{			var userVars:Array = [];			userVars.push(new SFSUserVariable(USERVAR_X, px));			userVars.push(new SFSUserVariable(USERVAR_Y, py));			userVars.push(new SFSUserVariable(USERVAR_DIR, dir));						sfs.send(new SetUserVariablesRequest(userVars));		}				/**		 * This method rearranges the avatars depths in their container (z-sorting).		 *		 * NOTE: as this would be out of the scope of this example, we didn't put too much effort		 * in the sorting method used to rearrange the avatar depths. In fact this method is not		 * particularly efficient, because at each animation step all avatars are rearranged.		 */		private function arrangeAvatars():void		{			// Sort avatars based on their y coordinate			avatars.sortOn("y", Array.NUMERIC)						var i:int = avatars.length						while (i--)			{				if (panel_chat.avArea.avContainer.getChildIndex(avatars[i]) != i)					panel_chat.avArea.avContainer.setChildIndex(avatars[i], i);			}		}				/**		 * This method creates the tween to animate the avatar from the current postion to the		 * destination coordinates saved in the User Variables.		 */		private function moveAvatar(user:User):void		{			var avatar:Avatar = getAvatar(user.id)						// Retrieve User Variables			var px:int = user.getVariable(USERVAR_X).getIntValue()			var py:int = user.getVariable(USERVAR_Y).getIntValue()			var dir:String = user.getVariable(USERVAR_DIR).getStringValue()						// Make avatar play walking animation			setAvatarGraphics(avatar, "walk", dir)						// Calculate animation duration			// (we want the avatar to move at a constant speed)			var dx:Number = px - avatar.x			var dy:Number = py - avatar.y			var dist:Number = Math.round(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)))						var duration:Number = Math.round(dist / AVATAR_SPEED)						// Move the avatar to the new position			// Check the tween class documentation here: http://www.greensock.com/as/docs/tween/						var twParams:Object = {}			twParams.x = px			twParams.y = py			twParams.ease = Linear.easeNone			twParams.onUpdate = onAvatarTweenUpdate			twParams.onUpdateParams = [avatar]			twParams.onComplete = onAvatarTweenComplete			twParams.onCompleteParams = [avatar,dir]						TweenNano.to(avatar, duration, twParams)		}				/**		 * This method updates the z-sorting of avatars at each animation step.		 */		private function onAvatarTweenUpdate(avatar:Avatar):void		{			arrangeAvatars()		}				/**		 * This method makes a walking avatar show the standing animation on movement completion.		 */		private function onAvatarTweenComplete(avatar:Avatar, dir:String):void		{			setAvatarGraphics(avatar, "stand", dir)		}				/**		 * This method hides the chat bubble.		 */		private function closeChatBubble(avatar:Avatar):void
		{
			clearTimeout(avatar.chatTimer)
			
			avatar.chatBubble.visible = false
		
		}
		
		
		 private function onExtensionResponse(evt:SFSEvent):void
     {
         
     }	}}